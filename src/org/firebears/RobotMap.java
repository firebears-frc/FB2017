// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.firebears;

//import org.firebears.util.CANTalon;
import org.firebears.util.LiquidCrystal;
import org.firebears.util.LiquidCrystal_roboRio;
import org.firebears.util.RobotReport;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.WpilibSpeedController;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.cscore.UsbCamera;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Ultrasonic;
import edu.wpi.first.wpilibj.drive.MecanumDrive;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {

	public static final boolean DEBUG = true;
	public static final boolean CHASSIS_BRAKE_MODE = true;
	public static final int CAN_FRONT_LEFT = 2;
	public static final int CAN_REAR_LEFT = 4;
	public static final int CAN_FRONT_RIGHT = 3;
	public static final int CAN_REAR_RIGHT = 5;
	public static final int CAN_CLIMBER = 11;
	public static final int CAN_FLOOR_LIFT = 12;
	public static final int CAN_ACQUISITION = 13;

	public static TalonSRX _chassisfrontLeft = null;
	public static TalonSRX _chassisfrontRight = null;
	public static TalonSRX _chassisrearLeft = null;
	public static TalonSRX _chassisrearRight = null;
	public static TalonSRX _climberclimbMotor = null;
	public static TalonSRX _floorfloorLift = null;
	public static TalonSRX _acquisitionacquisitionMotor = null;
	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static SpeedController chassisfrontLeft;
	public static SpeedController chassisfrontRight;
	public static SpeedController chassisrearLeft;
	public static SpeedController chassisrearRight;
	public static MecanumDrive chassisrobotDrive;
	public static SpeedController acquisitionacquisitionMotor;
	public static Servo dumperdumperServo;
	public static SpeedController floorfloorLift;
	public static SpeedController climberclimbMotor;
	public static Ultrasonic gearChuteultrasonic;
	// public static DigitalInput breakBeam;
	public static DigitalInput gearSensor;

	public static AnalogInput rangeFinder;
	public static AnalogInput rangeFinder2;

	public static LiquidCrystal lcd;

	public static CameraServer cameraServer;
	public static UsbCamera usbCamera0;
	public static UsbCamera usbCamera1;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	public static Encoder encoderLeft;
	public static Encoder encoderRight;

	public static Relay gearLightRing;

	public static AHRS navXBoard;

	static double m_P = 3.0f;// 1.25
	static double m_D = 0;
	static double m_ff = 0;
	static int m_izone = 256;
	static double m_I = 0;
	static double m_rampRate = 1;
	static int m_profile = 0;
	public static int m_CountPerRev = 1;
	
	public static final int pidIdx = 0;
	public static final int timeoutMs = 100;

	public static void init(RobotReport report) {

		//
		// //2 = Front Left
		// //3 = Front Right
		// //4 = Rear Left
		// //5 = Rear Right
		//

		_chassisfrontLeft = new TalonSRX(CAN_FRONT_LEFT);
		chassisfrontLeft = _chassisfrontLeft.getWPILIB_SpeedController();
		((WpilibSpeedController)chassisfrontLeft).setName("Chassis", "frontLeft");
//		LiveWindow.add((WpilibSpeedController)chassisfrontLeft);
		report.addCAN(CAN_FRONT_LEFT, "frontLeft", chassisfrontLeft);

		_chassisfrontRight = new TalonSRX(CAN_FRONT_RIGHT);
		chassisfrontRight = _chassisfrontRight.getWPILIB_SpeedController();
		((WpilibSpeedController)chassisfrontRight).setName("Chassis", "frontRight");
//		LiveWindow.add((WpilibSpeedController)chassisfrontRight);
		report.addCAN(CAN_FRONT_RIGHT, "frontRight", chassisfrontRight);

		_chassisrearLeft = new TalonSRX(CAN_REAR_LEFT);
		chassisrearLeft = _chassisrearLeft.getWPILIB_SpeedController();
		((WpilibSpeedController)chassisrearLeft).setName("Chassis", "rearLeft");
//		LiveWindow.add((WpilibSpeedController)chassisrearLeft);
		report.addCAN(CAN_REAR_LEFT, "frontRight", chassisrearLeft);

		_chassisrearRight = new TalonSRX(CAN_REAR_RIGHT);
		chassisrearRight = _chassisrearRight.getWPILIB_SpeedController();
		((WpilibSpeedController)chassisrearRight).setName("Chassis", "rearRight");
//		LiveWindow.add((WpilibSpeedController)chassisrearRight);
		report.addCAN(CAN_REAR_RIGHT, "rearRight", chassisrearRight);

		chassisrobotDrive = new MecanumDrive(chassisfrontLeft, chassisrearLeft,
				chassisfrontRight, chassisrearRight);
		chassisrobotDrive.setName("Chassis", "robotDrive");
		
		
		// START CLOSED LOOP PID
		_chassisfrontLeft.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, pidIdx, timeoutMs);
		_chassisfrontLeft.setSensorPhase(false);
		setPID(_chassisfrontLeft, m_P, m_I, m_D, m_ff, m_izone, m_rampRate, m_profile);
		_chassisfrontLeft.setNeutralMode(CHASSIS_BRAKE_MODE ? NeutralMode.Brake : NeutralMode.Coast);
		
		_chassisfrontRight.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, pidIdx, timeoutMs);
		_chassisfrontRight.setSensorPhase(false);
		setPID(_chassisfrontRight, m_P, m_I, m_D, m_ff, m_izone, m_rampRate, m_profile);
		_chassisfrontRight.setNeutralMode(CHASSIS_BRAKE_MODE ? NeutralMode.Brake : NeutralMode.Coast);
		
		_chassisrearLeft.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, pidIdx, timeoutMs);
		_chassisrearLeft.setSensorPhase(false);
		setPID(_chassisrearLeft, m_P, m_I, m_D, m_ff, m_izone, m_rampRate, m_profile);
		_chassisrearLeft.setNeutralMode(CHASSIS_BRAKE_MODE ? NeutralMode.Brake : NeutralMode.Coast);
		
		_chassisrearRight.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, pidIdx, timeoutMs);
		_chassisrearRight.setSensorPhase(false);
		setPID(_chassisrearRight, m_P, m_I, m_D, m_ff, m_izone, m_rampRate, m_profile);
		_chassisrearRight.setNeutralMode(CHASSIS_BRAKE_MODE ? NeutralMode.Brake : NeutralMode.Coast);
		
		m_CountPerRev = 255;

		chassisrobotDrive.setSafetyEnabled(true);
		chassisrobotDrive.setExpiration(0.1);
		chassisrobotDrive.setMaxOutput(400);
		// END CLOSED LOOP PID
		
		

		// chassisrobotDrive.setSafetyEnabled(true);
		// chassisrobotDrive.setExpiration(0.1);
		// chassisrobotDrive.setSensitivity(0.5);
		// chassisrobotDrive.setMaxOutput(1.0);
		// chassisrobotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontLeft, true);
		// chassisrobotDrive.setInvertedMotor(RobotDrive.MotorType.kRearLeft, true);
		//


		// Auto generated stuff

		dumperdumperServo = new Servo(0);
		dumperdumperServo.setName("Hopper", "dumperServo");
		LiveWindow.add(dumperdumperServo);
		report.addPWM(0, "dumperServo", dumperdumperServo);

		_floorfloorLift = new TalonSRX(CAN_FLOOR_LIFT);
		floorfloorLift = _floorfloorLift.getWPILIB_SpeedController();
		((WpilibSpeedController)floorfloorLift).setName("Floor", "floorLift");
		report.addCAN(CAN_FLOOR_LIFT, "floorLift", floorfloorLift);

		_climberclimbMotor = new TalonSRX(CAN_CLIMBER);
		climberclimbMotor = _climberclimbMotor.getWPILIB_SpeedController();
		((WpilibSpeedController)climberclimbMotor).setName("Climber", "climbMotor");
		report.addCAN(CAN_CLIMBER, "climbMotor", climberclimbMotor);

		_acquisitionacquisitionMotor = new TalonSRX(CAN_ACQUISITION);
		acquisitionacquisitionMotor = _acquisitionacquisitionMotor.getWPILIB_SpeedController();
    	((WpilibSpeedController)acquisitionacquisitionMotor).setName("Acquisition", "acquisitionMotor");
		report.addCAN(CAN_ACQUISITION, "acquisitionMotor", acquisitionacquisitionMotor);

		gearSensor = new DigitalInput(1);
		report.addDigitalIO(1, "gearSensor", gearSensor);
		gearSensor.setName("GearChute", "gearSensor");

		rangeFinder = new AnalogInput(0);
		report.addAnalogInput(0, "rangeFinder", rangeFinder);
		rangeFinder.setName("GearChute", "rangeFinder");

		rangeFinder2 = new AnalogInput(1);
		report.addAnalogInput(1, "rangeFinder2", rangeFinder2);
		rangeFinder2.setName("GearChute", "rangeFinder2");

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

		lcd = new LiquidCrystal_roboRio(0x3f); // 0x3f
		lcd.begin(20, 4);
		lcd.clear();
		report.addOtherConfig(0x3f, "I2C address of LCD display");

		// breakBeam = new DigitalInput(1);

		gearLightRing = new Relay(0, Relay.Direction.kForward);
		System.out.println("GearLightRing" + (gearLightRing != null));
		report.addRelay(0, "gearLightRing", gearLightRing);
		gearLightRing.setName("Vision", "lightRing");

		try {
			navXBoard = new AHRS(SPI.Port.kMXP);
		} catch (RuntimeException ex) {
			DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
		}
	}
	
	private static void setPID(TalonSRX talonSRX, double pidP, double pidI, double pidD, double pidF, int pidIZone, double pidRampRate,
			int slotIdx) {
		talonSRX.config_kP(slotIdx, pidP, timeoutMs);
		talonSRX.config_kI(slotIdx, pidI, timeoutMs);
		talonSRX.config_kD(slotIdx, pidD, timeoutMs);
		talonSRX.config_kF(slotIdx, pidF, timeoutMs);
		talonSRX.config_IntegralZone(slotIdx, pidIZone, timeoutMs);
		talonSRX.configClosedloopRamp(pidRampRate, timeoutMs);
		talonSRX.selectProfileSlot(slotIdx, pidIdx);
	}

	/**
	 * @return current NavXBoard angle wrapped to the range -180 to 180.
	 */
	public static double getNavXAngle() {
		return boundAngle(navXBoard.getAngle());
	}

	/**
	 * @return the angle wrapped into the range -180 to 180.
	 */
	public static double boundAngle(double angle) {
		while (angle > 180)
			angle -= 360;
		while (angle < -180)
			angle += 360;
		return angle;
	}
}
