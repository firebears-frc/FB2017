// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.firebears;

import org.firebears.util.LiquidCrystal;
import org.firebears.util.LiquidCrystal_roboRio;
import org.firebears.util.RobotReport;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;
import edu.wpi.cscore.UsbCamera;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.Ultrasonic;
import edu.wpi.first.wpilibj.drive.MecanumDrive;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into to a variable name.
 * This provides flexibility changing wiring, makes checking the wiring easier and significantly
 * reduces the number of magic numbers floating around.
 */
public class RobotMap {

  public static final boolean DEBUG = true;
  public static final boolean CHASSIS_BRAKE_MODE = true;
  public static final int CAN_FRONT_LEFT = 2;
  public static final int CAN_REAR_LEFT = 4;
  public static final int CAN_FRONT_RIGHT = 3;
  public static final int CAN_REAR_RIGHT = 5;
  public static final int CAN_CLIMBER = 11;
  public static final int CAN_FLOOR_LIFT = 12;
  public static final int CAN_ACQUISITION = 13;
  public static final boolean CLOSED_LOOP_DRIVING = true;
  public static final int COUNT_PER_REV = 255;
  public static final int PID_IDX = 0;
  public static final int TIMEOUT_MS = 10;

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  public static WPI_TalonSRX chassisfrontLeft = null;
  public static WPI_TalonSRX chassisfrontRight = null;
  public static WPI_TalonSRX chassisrearLeft = null;
  public static WPI_TalonSRX chassisrearRight = null;
  public static WPI_TalonSRX climberclimbMotor = null;
  public static WPI_TalonSRX floorfloorLift = null;
  public static WPI_TalonSRX acquisitionacquisitionMotor = null;

  public static MecanumDrive chassisrobotDrive;
  public static Servo dumperdumperServo;
  public static Ultrasonic gearChuteultrasonic;
  public static DigitalInput gearSensor;

  public static AnalogInput rangeFinder;
  public static AnalogInput rangeFinder2;

  public static LiquidCrystal lcd;

  public static CameraServer cameraServer;
  public static UsbCamera usbCamera0;
  public static UsbCamera usbCamera1;

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  public static Encoder encoderLeft;
  public static Encoder encoderRight;

  public static Relay gearLightRing;

  public static AHRS navXBoard;

  static double m_P = 3.0f;// 1.25
  static double m_D = 0;
  static double m_ff = 0;
  static int m_izone = 256;
  static double m_I = 0;
  static double m_rampRate = 1;
  static int m_profile = 0;



  public static void init(RobotReport report) {

    chassisfrontLeft = new CANTalon(CAN_FRONT_LEFT);
    chassisfrontLeft.setName("Chassis", "frontLeft");
    chassisfrontLeft.setNeutralMode(CHASSIS_BRAKE_MODE ? NeutralMode.Brake : NeutralMode.Coast);
    report.addCAN(CAN_FRONT_LEFT, "frontLeft", chassisfrontLeft);

    chassisfrontRight = new CANTalon(CAN_FRONT_RIGHT);
    chassisfrontRight.setName("Chassis", "frontRight");
    chassisfrontRight.setNeutralMode(CHASSIS_BRAKE_MODE ? NeutralMode.Brake : NeutralMode.Coast);
    report.addCAN(CAN_FRONT_RIGHT, "frontRight", chassisfrontRight);

    chassisrearLeft = new CANTalon(CAN_REAR_LEFT);
    chassisrearLeft.setName("Chassis", "rearLeft");
    chassisrearLeft.setNeutralMode(CHASSIS_BRAKE_MODE ? NeutralMode.Brake : NeutralMode.Coast);
    report.addCAN(CAN_REAR_LEFT, "frontRight", chassisrearLeft);

    chassisrearRight = new CANTalon(CAN_REAR_RIGHT);
    chassisrearRight.setName("Chassis", "rearRight");
    chassisrearRight.setNeutralMode(CHASSIS_BRAKE_MODE ? NeutralMode.Brake : NeutralMode.Coast);
    report.addCAN(CAN_REAR_RIGHT, "rearRight", chassisrearRight);

    chassisrobotDrive =
        new MecanumDrive(chassisfrontLeft, chassisrearLeft, chassisfrontRight, chassisrearRight);
    chassisrobotDrive.setName("Chassis", "robotDrive");


    if (CLOSED_LOOP_DRIVING) {

      chassisfrontLeft.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, PID_IDX, TIMEOUT_MS);
      chassisfrontLeft.setSensorPhase(false);
      setPID(chassisfrontLeft, m_P, m_I, m_D, m_ff, m_izone, m_rampRate, m_profile);

      chassisfrontRight.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, PID_IDX, TIMEOUT_MS);
      chassisfrontRight.setSensorPhase(false);
      setPID(chassisfrontRight, m_P, m_I, m_D, m_ff, m_izone, m_rampRate, m_profile);

      chassisrearLeft.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, PID_IDX, TIMEOUT_MS);
      chassisrearLeft.setSensorPhase(false);
      setPID(chassisrearLeft, m_P, m_I, m_D, m_ff, m_izone, m_rampRate, m_profile);

      chassisrearRight.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, PID_IDX, TIMEOUT_MS);
      chassisrearRight.setSensorPhase(false);
      setPID(chassisrearRight, m_P, m_I, m_D, m_ff, m_izone, m_rampRate, m_profile);

      chassisrobotDrive.setSafetyEnabled(true);
      chassisrobotDrive.setExpiration(0.1);
      chassisrobotDrive.setMaxOutput(400);
    }


    // Auto generated stuff

    dumperdumperServo = new Servo(0);
    dumperdumperServo.setName("Hopper", "dumperServo");
    LiveWindow.add(dumperdumperServo);
    report.addPWM(0, "dumperServo", dumperdumperServo);

    floorfloorLift = new WPI_TalonSRX(CAN_FLOOR_LIFT);
    floorfloorLift.setName("Floor", "floorLift");
    report.addCAN(CAN_FLOOR_LIFT, "floorLift", floorfloorLift);

    climberclimbMotor = new WPI_TalonSRX(CAN_CLIMBER);
    climberclimbMotor.setName("Climber", "climbMotor");
    report.addCAN(CAN_CLIMBER, "climbMotor", climberclimbMotor);

    acquisitionacquisitionMotor = new WPI_TalonSRX(CAN_ACQUISITION);
    acquisitionacquisitionMotor.setName("Acquisition", "acquisitionMotor");
    report.addCAN(CAN_ACQUISITION, "acquisitionMotor", acquisitionacquisitionMotor);

    gearSensor = new DigitalInput(1);
    report.addDigitalIO(1, "gearSensor", gearSensor);
    gearSensor.setName("GearChute", "gearSensor");

    rangeFinder = new AnalogInput(0);
    report.addAnalogInput(0, "rangeFinder", rangeFinder);
    rangeFinder.setName("GearChute", "rangeFinder");

    rangeFinder2 = new AnalogInput(1);
    report.addAnalogInput(1, "rangeFinder2", rangeFinder2);
    rangeFinder2.setName("GearChute", "rangeFinder2");

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    lcd = new LiquidCrystal_roboRio(0x3f); // 0x3f
    lcd.begin(20, 4);
    lcd.clear();
    report.addOtherConfig(0x3f, "I2C address of LCD display");

    // breakBeam = new DigitalInput(1);

    gearLightRing = new Relay(0, Relay.Direction.kForward);
    System.out.println("GearLightRing" + (gearLightRing != null));
    report.addRelay(0, "gearLightRing", gearLightRing);
    gearLightRing.setName("Vision", "lightRing");

    try {
      navXBoard = new AHRS(SPI.Port.kMXP);
    } catch (RuntimeException ex) {
      DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
    }
  }

  private static void setPID(TalonSRX talonSRX, double pidP, double pidI, double pidD, double pidF,
      int pidIZone, double pidRampRate, int slotIdx) {
    talonSRX.configClosedloopRamp(pidRampRate, TIMEOUT_MS);
    talonSRX.configNominalOutputForward(0.0, TIMEOUT_MS);
    talonSRX.configNominalOutputReverse(0.0, TIMEOUT_MS);
    talonSRX.configPeakOutputForward(1.0, TIMEOUT_MS);
    talonSRX.configPeakOutputReverse(-1.0, TIMEOUT_MS);
    talonSRX.config_kP(slotIdx, pidP, TIMEOUT_MS);
    talonSRX.config_kI(slotIdx, pidI, TIMEOUT_MS);
    talonSRX.config_kD(slotIdx, pidD, TIMEOUT_MS);
    talonSRX.config_kF(slotIdx, pidF, TIMEOUT_MS);
    talonSRX.config_IntegralZone(slotIdx, pidIZone, TIMEOUT_MS);
    talonSRX.selectProfileSlot(slotIdx, PID_IDX);
  }

  /**
   * @return current NavXBoard angle wrapped to the range -180 to 180.
   */
  public static double getNavXAngle() {
    return boundAngle(navXBoard.getAngle());
  }

  /**
   * @return the angle wrapped into the range -180 to 180...
   */
  public static double boundAngle(double angle) {
    while (angle > 180) {
      angle -= 360;
    }
    while (angle < -180) {
      angle += 360;
    }
    return angle;
  }


  static class CANTalon extends WPI_TalonSRX {
    public CANTalon(int deviceNumber) {
      super(deviceNumber);
    }

    @Override
    public void set(double speed) {
      if (CLOSED_LOOP_DRIVING) {
        set(ControlMode.Velocity, speed * COUNT_PER_REV);
      } else {
        set(ControlMode.PercentOutput, speed);
      }
    }

    @Override
    public String toString() {
      return "CANTalon(" + getDeviceID() + ")";
    }
  }
}
